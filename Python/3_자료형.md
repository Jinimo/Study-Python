## 1. boolean과 비교, 논리 연산자 

참(True), 거짓(False)을 나타내는 불(boolean)

비교 연산자

| 연산자 |    문법    |            설명            |
| :----: | :--------: | :------------------------: |
|   ==   |   a == b   |            같음            |
|   !=   |   a != b   |      같지 않음, 다름       |
|   >    |   a > b    |          큼, 초과          |
|   <    |   a < b    |         작음, 미만         |
|   >=   |   a >= b   |     크거나 같음, 이상      |
|   <=   |   a <= b   |     작거나 같음, 이하      |
|   is   |   a is b   |      같음(객체 비교)       |
| is not | a is not b | 같지 않음, 다름(객체 비교) |



논리 연산자

| 연산자 |  문법   |                  설명                  |
| :----: | :-----: | :------------------------------------: |
|  and   | a and b |   AND(논리곱), 양쪽 모두 참일 때 참    |
|   or   | a or b  | OR(논리합), 양쪽 중 한쪽만 참이라도 참 |
|  not   |  not x  |   NOT(논리 부정), 참과 거짓을 뒤집음   |

- 8.1 boolean과 비교 연산자 

```py
## 비교 연산 판단 
>>> 3 > 1
True
## 숫자 비교
>>> 10 == 10    # 10과 10이 같은지 비교
True
>>> 10 != 5     # 10과 5가 다른지 비교
True
## 문자열 비교
>>> 'Python' == 'Python'
True
>>> 'Python' == 'python'
False
>>> 'Python' != 'python'
True

## 부등호
>>> 10 > 20    # 10이 20보다 큰지 비교
False
>>> 10 < 20    # 10이 20보다 작은지 비교
True
>>> 10 >= 10    # 10이 10보다 크거나 같은지 비교
True
>>> 10 <= 10    # 10이 10보다 작거나 같은지 비교
True

## 객체 비교
# ==, !=는 값 자체를 비교하고, is, is not은 객체(object)를 비교
>>> 1 == 1.0 # 정수와 실수라는 차이점이 있지만 값은 같음
True
>>> 1 is 1.0 # 1은 정수 객체, 1.0은 실수 객체
False
>>> 1 is not 1.0
True

## 참고) 정수 실수 객체 차이점 
# id() 함수 이용 -> 객체의 고유한 값(메모리 주소)을 구함 
# 파이썬을 실행하는 동안에는 계속 유지되며 다시 실행하면 달라짐
# 정수와 실수 고유값 다름 ! 
>>> id(1)
1714767504
>>> id(1.0)
55320032

## 참고) 값 비교 -> is 사용 X
#  a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문
# 다른 객체가 되므로 값이 같더라도 is로 비교하면 False가 나옴
# 값(숫자)를 비교할 때는 is가 아닌 비교 연산자를 사용
>>> a = -5
>>> a is -5
True
>>> a = -6
>>> a is -6
False
```



- 8.2 boolean과 논리 연산자 

```py
## a and b
# 두 값이 모두 True -> True, 하나라도 False -> False
>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False

## a or b
# 두 값 중 하나라도 True -> True, 모두 False여야 -> False
>>> True or True
True
>>> True or False
True
>>> False or True
True
>>> False or False
False

## not x
# 논릿값을 뒤집기
>>> not True
False
>>> not False
True
# nd, or, not 논리 연산자가 식 하나에 존재 -> not, and, or 순으로 판단
>>> not True and False or not False
True
```



## 2. 리스트 & 튜플

### - 리스트

여러 개의 값(요소)을 일렬로 늘어놓은 형태

변수에 값을 저장할 때 대괄호 [ ]로 묶어줌. 각 값은 ,(콤마)로 구분

리스트 요소로 여러 자료형 섞어서 사용 가능 

리스트에 저장된 요소에 접근할 때는 [ ] 안에 인덱스를 지정 (인덱스 0부터 시작)

```py
# 리스트 만들기
리스트 = [값, 값, 값] 
# 빈 리스트 만들기
리스트 = []
리스트 = list()
# range로 리스트 만들기
리스트 = list(range(횟수))
리스트 = list(range(시작, 끝))
리스트 = list(range(시작, 끝, 증가폭))

리스트[인덱스]                # 리스트의 요소에 접근
리스트[0]                   # 리스트의 인덱스는 0부터 시작하므로 첫 번째 요소
리스트[인덱스] = 값           # 리스트의 요소에 값 저장
```



- Range

연속된 숫자를 생성

지정한 횟수는 생성되는 숫자에 포함 X

작하는 숫자와 끝나는 숫자를 지정했을 때 -> 끝나는 숫자는 생성되는 숫자에 포함 X

```py
range(횟수)
range(시작, 끝)
range(시작, 끝, 증가폭)
```



### - 튜플

튜플은 여러 개의 값(요소)을 일렬로 늘어놓은 형태

변수에 값을 저장할 때 ( )(괄호)로 묶어줌.  각 값은 ,(콤마)로 구분

괄호로 묶지 않고 값만 콤마로 구분해도 튜플

튜플도 리스트처럼 여러 자료형을 섞어서 저장 가능 

튜플에 저장된 요소에 접근할 때는 [ ] 안에 인덱스를 지정 (인덱스 0부터 시작)

저장된 요소를 변경, 추가, 삭제할 수도 없음 (읽기전용) -> 튜플은 요소가 절대 변경되지 않고 유지되어야 할 때 사용

```py
# 튜플 만들기
튜플 = (값, 값, 값)
튜플 = 값, 값, 값   # 괄호 사용하지 않아도 가능 
튜플 = ()         # 빈 튜플 만들기

# 요소 1개 튜플
튜플 = (값, )
튜플 = 값,

튜플 = tuple()
# list
튜플 = tuple(리스트)
튜플 = tuple(list())
# range
튜플 = tuple(range(횟수))
튜플 = tuple(range(시작, 끝))
튜플 = tuple(range(시작, 끝, 증가폭))

# 튜플 요소 접근 
튜플[인덱스]               
튜플[0]			# 튜플의 인덱스는 0부터 시작하므로 첫 번째 요소  

# 리스트 -> 튜플
a = [1, 2, 3]
tuple(a)
# 튜플 -> 리스트
b = (4, 5, 6)
list(b)
```



```py
## list와 tuple 안에 문자열을 넣으면?
# list와 tuple에 문자열을 넣으면 문자 리스트, 문자 튜플이 생성
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']
>>> tuple('Hello')
('H', 'e', 'l', 'l', 'o')

## 리스트와 튜플로 변수 만들기
# 리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있음
# 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 함
>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3
>>> d, e, f = (4, 5, 6)
>>> print(d, e, f)
4 5 6

# 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)
>>> x = [1, 2, 3]
>>> a, b, c = x
>>> print(a, b, c)
1 2 3
>>> y = (4, 5, 6)
>>> d, e, f = y
>>> print(d, e, f)
4 5 6

# 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장
>>> input().split()
10 20
['10', '20']
>>> x = input().split()
10 20
>>> a, b = x         # a, b = input().split()과 같음
>>> print(a, b)
10 20


# 리스트 패킹(list packing)과 튜플 패킹(tuple packing)
# 변수에 리스트 또는 튜플을 할당하는 과정
a = [1, 2, 3]    # 리스트 패킹
b = (1, 2, 3)    # 튜플 패킹
c = 1, 2, 3      # 튜플 패킹
```



## 3. 시퀀스 자료형

연속적(sequence)

시퀀스 자료형(sequence types): 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형

 list, tuple, range, str

시퀀스 자료형으로 만든 객체를 시퀀스 객체

시퀀스 객체에 들어있는 각 값을 요소(element)

```py
# 특정 값 있는지 확인 (T/F)
값 in 시퀀스객체
값 not in 시퀀스객체

# 시퀀스 객체 연결 -> 새 시퀀스 객체 생성 (range는 리스트 or 튜플로 만들어서!)
시퀀스객체1 + 시퀀스객체2
# 시퀀스 객체 반복 -> 새 시퀀스 객체 생성 (range는 리스트 or 튜플로 만들어서!)
시퀀스객체 * 정수
정수 * 시퀀스객체

# 시퀀스 객체의 요소 개수(길이)
len(시퀀스객체)    # 리스트 튜플 
len(range(횟수)) # range
len('문자열')     # 문자열의 길이는 공백까지 포함

# 시퀀스 객체의 요소에 접근
시퀀스객체[인덱스] 
시퀀스객체.__getitem__(인덱스)
시퀀스객체[0]               # 시퀀스 객체의 인덱스는 0부터 시작하므로 첫 번째 요소
시퀀스객체[-음수]            # 인덱스를 음수로 지정하면 뒤에서부터 요소에 접근
시퀀스객체[-1]              # -1은 뒤에서 첫 번째
시퀀스객체[n-1]             # 인덱스는 0 ~ n-1이기 때문에 (총 개수가 n개의 요소인 경우)
시퀀스객체[len(시퀀스객체)-1]

# 시퀀스 객체의 요소에 값 저장 (튜플, range -> 값 변경 X)
시퀀스객체[인덱스] = 값       

# 시퀀스 객체의 요소를 삭제 (튜플, range -> 값 삭제 X)
del 시퀀스객체[인덱스]       
```

- 특정 값 있는지 확인 (T/F)

```py
# 예시
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> 30 in a
True
>>> 100 in a
False
>>> 43 in (38, 76, 43, 62, 19)
True
>>> 1 in range(10)
True
>>> 'P' in 'Hello, Python'
True
```

- 시퀀스 객체 연결

```py
시퀀스객체1 + 시퀀스객체2

# 예시
>>> a = [0, 10, 20, 30]
>>> b = [9, 8, 7, 6]
>>> a + b
[0, 10, 20, 30, 9, 8, 7, 6]

# range는 + 연산자로 객체를 연결할 수 없음
# range를 리스트 또는 튜플로 만들어서 연결
>>> list(range(0, 10)) + list(range(10, 20))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> tuple(range(0, 10)) + tuple(range(10, 20))
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)

# 문자열 연결 
>>> 'Hello, ' + 'world!'
'Hello, world!'

# 문자열 + 숫자 연결
'문자열' + str(정수)
'문자열' + str(실수)
```

- 
